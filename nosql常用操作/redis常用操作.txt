增
{
SET key value
}


删
{
DEL key [key …]
}


改
{
追加：APPEND key value
SET key value
}


查
{
GET key	
获取字符串长度：STRLEN key

同时获得/设置多个键值
MGET key [key …]
MSET key value [key value …]
redis> MSET key1 v1 key2 v2 key3 v3
redis> MGET key1 key3
}

other
{
递增数字:	INCR key
增加指定的整数:	INCRBY key increment
减少:	DECR key
	DECRBY key decrement
}


散列/哈希
{
	赋值与取值
	HSET key field value
	HGET key field
	HMSET key field value [field value …]
	HMGET key field [field …]
	HGETALL key

	redis> HSET car price 500
	(integer) 1
	redis> HSET car name BMW
	(integer) 1
	redis> HGET car name
	"BMW"


	HMSET key field1 value1 field2 value2
	redis> HMGET car price name

	判断字段是否存在
	HEXISTS key field
}

列表（类似于栈，栈顶为index=0）
{
	LPUSH w3ckey redis
	LINDEX key index 通过索引获取列表中的元素
	LLEN key 获取列表长度
	LPOP key 移出并获取列表的第一个元素
	LRANGE key start stop 获取列表指定范围内的元素
}

集合set{
	SADD key member1 [member2] 向集合添加一个或多个成员
	SCARD key 获取集合的成员数
	SMEMBERS key 返回集合中的所有成员
	SISMEMBER key member 判断 member 元素是否是集合 key 的成员

	SDIFF key1 [key2] 返回给定所有集合的差集
	SINTER key1 [key2] 返回给定所有集合的交集
	SUNION key1 [key2] 返回所有给定集合的并集
	SUNIONSTORE destination key1 [key2] 所有给定集合的并集存储在 destination 集合中
}

有序集合set{
	redis正是通过分数来为集合中的成员进行从小到大的排序。
	有序集合的成员是唯一的,但分数(score)却可以重复。
	ZADD zset 1 redis 1 aaa 2 mysql 3 mongo 3 monga

	ZADD key score1 member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数
	ZCARD key 获取有序集合的成员数
	ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合成指定区间内的成员
}

Redis 发布订阅{
	SUBSCRIBE channel [channel ...] 订阅给定的一个或多个频道的信息。
	PUBLISH channel message 将信息发送到指定的频道。
}

事务命令{
	DISCARD 取消事务，放弃执行事务块内的所有命令。
	EXEC 执行所有事务块内的命令。
	MULTI 标记一个事务块的开始。
	UNWATCH 取消 WATCH 命令对所有 key 的监视。
	WATCH key [key ...] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。
}




//--批量执行redis命令--------------
1.创建命令文件redis.txt，存储命令，每条命令要换行，中间有空行的意思
2.cat redis.txt | ./redis-cli -h $host -p $port -a $password --pipe
//---------------------------------


备份{
在客户端执行save命令即会生成dump.rdb备份文件，该文件存储的路径可以通过命令CONFIG GET dir查看
}

